const functions = require("firebase-functions");

const admin = require("firebase-admin");
// import the 'firebase-functions' module and makes it avalaible via this 'functions' identifier:

// initialize an admin app instance from which Realtime Database changes can be made:
admin.initializeApp();

// The Cloud Function named formatData below responds to any node creation 
// in the database path '/measures/{pushId}/', for instance 1023 in case
// of maximum luminosity. {pushId} (with curly braces) is a wildcard,
// representing for us the autogenerated pushId associated with the newly
// pushed measure, for instance '-LGuXlb0GZfwbKs0Rf8Y'.
exports.formatData = functions.database.ref('/NodeMcu/{pushId}/')
    .onCreate(
        // The onCreate() trigger function requires a handler function that itself
        // receives 2 arguments: We name them snapshot and context.
        // (The handler function is written here as an anonymous function with
        // fat arrow syntax.)
        (snapshot, context) => {
            // Grab the current value of what was written to the Realtime Database
            // by applying val() method to the snapshot raw object:
            const original = snapshot.val(); // 1023
            // Grab the wildcard we called pushId in the database path. It lies
            // in the context object:
            const pushId = context.params.pushId; // '-LGuXlb0GZfwbKs0Rf8Y'
            // Let's print them in Firebase Console (use of template literals syntax):
            console.log(`Detected new measure ${original} with pushId ${pushId}`);
            // Let's push to 'timestamped_measures' node a new object
            // with an autogenerated push ID for key and a 2-property object for value:
            return admin.database().ref('timestamped_measures').push({
                value: original,
                timestamp: admin.database.ServerValue.TIMESTAMP // will be Epoch time in ms
            });
        });
        // Why 'return' at the end of the handler function, in front
        // of the push method?
        // In fact, the handler function must return a Promise, an object that ends
        // up 'resolved' or 'rejected', thus indicating to the Cloud Function
        // it can close as the work is done.
        // push() does asynchronous work. Unsurprisingly, push() returns a Promise.
        // This is the one the handler function shall return.